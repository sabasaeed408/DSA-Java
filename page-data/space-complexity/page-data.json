{"componentChunkName":"component---src-templates-lesson-template-js","path":"/space-complexity","result":{"data":{"markdownRemark":{"html":"<p>Now that we have learned about 'time' aspect of performance analysis of an algorithm, let's move on to memory aspect of the same.</p>\n<p><em><strong>Space complexity of an algorithm is basically the amount of memory it needs to run to completion.</strong></em></p>\n<p>It is a way to establish approximate relationship between size of input data and primary memory used by the algorithm to produce the expected result.</p>\n<p>Calculation of space complexity used to hold much more significance in early days of computing than it does now. This is because most machines today have large memories and the user does not need to worry about running out of memory for running a program or two. But it is a crucial estimate where the physical memory is limited or closely monitored.</p>\n<h2 id=\"calculation-of-space-complexity\" style=\"position:relative;\"><a href=\"#calculation-of-space-complexity\" aria-label=\"calculation of space complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Calculation of Space Complexity</strong></h2>\n<p>An algorithm's space can be categorized into 2 parts:<br>\n<strong>1)Fixed Part</strong> which is independent of characteristics of input and output.<br>\nIt includes instruction(code) space, space for simple variables, fixed-size component variables and constants.<br>\n<strong>2)Variable Part</strong> which depends on instance characteristics.<br>\nIt consists of the space needed by component variables whose size is dependent on the particular problem instance being solved, the space needed by referenced variables, and the recursion stack space.</p>\n<p>Thus, space requirement S(P) of any algorithm P is:</p>\n<blockquote>\n<p>S(P) = c + Sp (Instance characteristics), where c is constant</p>\n</blockquote>\n<p>While analyzing space complexity, we primarily concentrate on estimating Sp.\nConsider following algorithm:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Algorithm Calc(a, b, c)\n{\n  return a + b - c*a + b/c - a;\n}</code></pre></div>\n<p>Here, problem instance depends only upon <em>a</em>,<em>b</em> and <em>c</em> which can be considered constant(fixed part). Thus <em><strong>Sp=0</strong></em>. So, the space required by <em>Calc</em> algorithm is constant. In other words, complexity is O(1).</p>\n<p>When the program consists of loops (In case of Iterative algorithms), it will have linear space complexity or O(n).\nWhile dealing with operations on data structures, we can say that space complexity depends on size of the data structure. For example, if an array stores N elements, its space complexity is O(n). A program with an array of N arrays will have space complexity O(n^2) and so on.</p>\n<p>Space complexity analysis also takes into account the size of recursion stack in case of recursive algorithms. for example,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Algorithm Fact(n)\n{\n  if (n&lt;=0) return 1;\n  else  return n * (n - 1);\n}</code></pre></div>\n<p>In this case there are 3 statements (1 if &#x26; 2 return statements). The depth of recursion is <em>n + 1</em>. Thus the recursion stack space needed is >=3(n+1). So we can say, space complexity is O(n) i.e. linear.</p>\n<p><em><strong>NOTE: Space complexity might differ from machine to machine based on the programming language, the compiler etc.</strong></em></p>\n<h2 id=\"space-complexities-of-common-algorithms\" style=\"position:relative;\"><a href=\"#space-complexities-of-common-algorithms\" aria-label=\"space complexities of common algorithms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Space Complexities of Common Algorithms</strong></h2>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Space Complexity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Linear Search</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Binary Search</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Bubble Sort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Insertion Sort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Selection Sort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Heapsort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Shell Sort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Quicksort</td>\n<td>O(log(n))</td>\n</tr>\n<tr>\n<td>Mergesort</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Timsort</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Tree Sort</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Bucket Sort</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Radix Sort</td>\n<td>O(n+k)</td>\n</tr>\n<tr>\n<td>Counting Sort</td>\n<td>O(k)</td>\n</tr>\n</tbody>\n</table>","frontmatter":{"path":"/space-complexity","title":"Space Complexity","order":"7C","section":"Space & Time Complexity"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"4B","path":"/arraylist","title":"ArrayList In Java"}}},{"node":{"frontmatter":{"order":"4A","path":"/arrays","title":"Introduction to Arrays"}}},{"node":{"frontmatter":{"order":"24A","path":"/assignment","title":"Assignments"}}},{"node":{"frontmatter":{"order":"9E","path":"/backtrack-maze","title":"Maze Problems"}}},{"node":{"frontmatter":{"order":"9D","path":"/backtrack-nknight","title":"N Knights"}}},{"node":{"frontmatter":{"order":"9B","path":"/backtrack-sudoku","title":"Sudoku Solver"}}},{"node":{"frontmatter":{"order":"9A","path":"/backtracking","title":"Introduction to Backtracking"}}},{"node":{"frontmatter":{"order":"5B","path":"/binarysearch","title":"Binary Search"}}},{"node":{"frontmatter":{"order":"10B","path":"/bitwise-operator","title":"Complete Bitwise Operators"}}},{"node":{"frontmatter":{"order":"4D","path":"/bmmv-algorithm","title":"Boyer-Moore Majority Voting Algorithm"}}},{"node":{"frontmatter":{"order":"9C","path":"/backtrack-nqueen","title":"N Queens"}}},{"node":{"frontmatter":{"order":"5C","path":"/bubblesort","title":"Bubble Sort"}}},{"node":{"frontmatter":{"order":"5F","path":"/countsort","title":"Count Sort"}}},{"node":{"frontmatter":{"order":"5H","path":"/cyclesort","title":"Cyclic Sort"}}},{"node":{"frontmatter":{"order":"3A","path":"/dataTypes","title":"Learn Data Types"}}},{"node":{"frontmatter":{"order":"2C","path":"/firstjavaprogram","title":"First Java Program"}}},{"node":{"frontmatter":{"order":"8B","path":"/flow-of-recursion","title":"Flow of Recursion"}}},{"node":{"frontmatter":{"order":"2A","path":"/flowchart","title":"Flowchart & Pseudocode"}}},{"node":{"frontmatter":{"order":"3F","path":"/functions","title":"Function & Scope"}}},{"node":{"frontmatter":{"order":"20A","path":"/greedy","title":"Introduction to Greedy Algorithms"}}},{"node":{"frontmatter":{"order":"5E","path":"/insertion","title":"Insertion Sort"}}},{"node":{"frontmatter":{"order":"15A","path":"/intro-binarytree","title":"Intro to Binary Tree"}}},{"node":{"frontmatter":{"order":"16A","path":"/intro-bst","title":"Intro to BST"}}},{"node":{"frontmatter":{"order":"7A","path":"/intro-complexity","title":"Complexity Analysis"}}},{"node":{"frontmatter":{"order":"19A","path":"/intro-dp","title":"Introduction to DP"}}},{"node":{"frontmatter":{"order":"12A","path":"/intro-ds","title":"Introduction to Data Structures"}}},{"node":{"frontmatter":{"order":"22A","path":"/intro-graphs","title":"Introduction to Graphs"}}},{"node":{"frontmatter":{"order":"18A","path":"/intro-hashmap","title":"Introduction to Hashmap"}}},{"node":{"frontmatter":{"order":"17A","path":"/intro-heap","title":"Introduction to Heaps"}}},{"node":{"frontmatter":{"order":"12B","path":"/intro-linkedlist","title":"Introduction to Linked List"}}},{"node":{"frontmatter":{"order":"10A","path":"/intro-maths","title":"Introduction to Maths in DSA"}}},{"node":{"frontmatter":{"order":"11A","path":"/intro-oop","title":"Introduction"}}},{"node":{"frontmatter":{"order":"21A","path":"/intro-priorityqueues","title":"Introduction to Priority Queues"}}},{"node":{"frontmatter":{"order":"1B","path":"/intro-programming","title":"Intro to Programming"}}},{"node":{"frontmatter":{"order":"8A","path":"/intro-recursion","title":"Intro to Recursion"}}},{"node":{"frontmatter":{"order":"13A","path":"/intro-stacks","title":"Intro to Stack"}}},{"node":{"frontmatter":{"order":"6A","path":"/intro-string","title":"Intro to Strings"}}},{"node":{"frontmatter":{"order":"14A","path":"/intro-trees","title":"Intro to Trees"}}},{"node":{"frontmatter":{"order":"23A","path":"/intro-tries","title":"Introduction to Tries"}}},{"node":{"frontmatter":{"order":"1A","path":"/introduction","title":"Welcome"}}},{"node":{"frontmatter":{"order":"3C","path":"/io-conditionals","title":"Input/Output & Conditionals"}}},{"node":{"frontmatter":{"order":"2B","path":"/java-setup","title":"Java Development Setup"}}},{"node":{"frontmatter":{"order":"3E","path":"/jumps","title":"Jumps Statements"}}},{"node":{"frontmatter":{"order":"5A","path":"/linearsearch","title":"Linear Search"}}},{"node":{"frontmatter":{"order":"3D","path":"/loops","title":"Loops In Java"}}},{"node":{"frontmatter":{"order":"8E","path":"/mergesort","title":"Merge Sort"}}},{"node":{"frontmatter":{"order":"10C","path":"/num-one","title":"Number Theory Part-A"}}},{"node":{"frontmatter":{"order":"10E","path":"/num-three","title":"Number Theory Part-C"}}},{"node":{"frontmatter":{"order":"10D","path":"/num-two","title":"Number Theory Part-B"}}},{"node":{"frontmatter":{"order":"3B","path":"/operators","title":"Operators in Java"}}},{"node":{"frontmatter":{"order":"5I","path":"/practise-question","title":"Practise Questions"}}},{"node":{"frontmatter":{"order":"4C","path":"/print-patterns","title":"Printing Patterns"}}},{"node":{"frontmatter":{"order":"11C","path":"/properties","title":"Properties of OOP"}}},{"node":{"frontmatter":{"order":"8F","path":"/quicksort","title":"Quick Sort"}}},{"node":{"frontmatter":{"order":"5G","path":"/radixsort","title":"Radix Sort"}}},{"node":{"frontmatter":{"order":"7D","path":"/recurrence","title":"Recurrence Relations"}}},{"node":{"frontmatter":{"order":"8C","path":"/recursion-arrays","title":"Recursion & Array"}}},{"node":{"frontmatter":{"order":"8G","path":"/recursion-practise","title":"Standard Practise Questions"}}},{"node":{"frontmatter":{"order":"8D","path":"/recursion-string","title":"Recursion & Strings"}}},{"node":{"frontmatter":{"order":"5D","path":"/selectionsort","title":"Selection Sort"}}},{"node":{"frontmatter":{"order":"7C","path":"/space-complexity","title":"Space Complexity"}}},{"node":{"frontmatter":{"order":"6B","path":"/string-builder","title":"StringBuilder in Java"}}},{"node":{"frontmatter":{"order":"4E","path":"/subarrays","title":"Subarrays"}}},{"node":{"frontmatter":{"order":"11B","path":"/this-constructor","title":"this Keyword & Constructor"}}},{"node":{"frontmatter":{"order":"7B","path":"/time-complexity","title":"Time Complexity"}}}]}},"pageContext":{}},"staticQueryHashes":["137611351"]}